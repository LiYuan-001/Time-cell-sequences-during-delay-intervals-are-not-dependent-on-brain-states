% This code is to define the maze shape and calculate animal position
% accordingly
% Li Yuan, Aug-05-2020, UCSD
function Fig8TreadPos(inFile,AnalyzeSes)

% set up parameters
p.speed = 180; % maximum speed: cm/sec
p.sleepSpeed = 100; % maximum speed: cm/sec
p.frameRate = 30; % consider using Header from neuralynx recording file
p.timeThreshold = 1;
p.sampRate = 30; % sampling frequency from camera
p.mazeSize = [40.5 5*12]*2.54; % length in x and y dimention 5 feet, 40.5 inch *2.54(cm)
p.sleepSize = [30,50];
p.smoothSize = 3; % positions used to smooth the path (+-)
%--------------------------------------------------------------------------
p.overwrite = 1; % whether to overwrite exsiting analyzed path files
p.parsemode = 'rdscr'; % define maze
p.mazetype = 'fig8Treadmill';
%--------------------------------------------------------------------------
% This maze segment definition part is inherited from previous existed
% code. Except center maze, all other part are useful. On center arm, a
% finer definition of delay and running part need to be defined. I will
% specify in other codes
% -- Li, 2020-Aug-05, UCSD
% 
% parameters for fig8maze 
regToUse = {'center','choice','base', 'return', 'reward', 'choiceEnd'};
regLocs.center = {'A25'};
regLocs.choice = {'N5'};
regLocs.base = {'A56','A45'};
regLocs.return = {'A16','N1','A12','A23','N3','A34'};
regLocs.reward = {'N6','N4'};
regLocs.choiceEnd = {'N2'};
%--------------------------------------------------------------------------

% Read in input information
sessInfo = SessInfoImport(inFile);

% define maze size for each recording day
for i = AnalyzeSes(1:end)
    
    savefolder = fullfile(sessInfo(i).mainDir,'processedData');
    if ~exist(savefolder, 'dir')
        mkdir(savefolder);
    end   
    % get each phase names (no delay etc)
    SessDirs = sessInfo(i).sessDirs;   
    
    if prod(~isempty(char(SessDirs{1}))) % check wheteher is NaN
        
        % use first session to define maze shape
        for ii = 1
            
            disp(strcat('Start reading the input data for: ',fullfile(sessInfo(i).mainDir, SessDirs{ii})));
            % Get the name of the video file
            videoFile = fullfile(sessInfo(i).mainDir,SessDirs{ii},'VT1.Nvt');
            % extract position from the video file
            [t, x, y,~] = ProcessVideoData2(videoFile,sessInfo(i).diode,p);
            n_samples = length(x); % wrong, should be a cumulative summation % Li Yuan
            n_trackingPoints = n_samples; % these two line from old code
            % becuase it is saved in the output, so I kept it
            
            % search if there is defined maze shape
            if exist(fullfile(sessInfo(i).mainDir,'processedData', 'maze_coordinates.mat'), 'file')==2
                load(fullfile(sessInfo(i).mainDir,'processedData', 'maze_coordinates.mat'));
            end
            if exist('coord', 'var')
                SW = coord.SW; SE= coord.SE; NE= coord.NE; NW = coord.NW;
            else
                % Find border values for path and box
                maxX = max(x);
                minX = min(x);
                maxY = max(y);
                minY = min(y);
                
                % Set the corners of the reference box
                NE = [maxX, maxY]
                NW = [minX, maxY]
                SW = [minX, minY]
                SE = [maxX, minY]
                clear coord.line
                linecoordinates = [mean([NE;NW]);mean([SE;SW])];
                coord.line = [linecoordinates(:,1),linecoordinates(:,2)]
            end
            
            % plot out the shape
            f = figure;
            plot(x,y);
            axis equal
            title(num2str(i))
            max(x);
            h = impoly(gca, [SW; SE; NE; NW])
            setColor(h,'red');
            %addNewPositionCallback(h,@(p) title(mat2str(p,3)));
            fcn = makeConstrainToRectFcn('impoly',get(gca,'XLim'),get(gca,'YLim'));
            setPositionConstraintFcn(h,fcn);
            
            ll = imline(gca,coord.line); %
            setColor(ll,[1 0 1]);
            
            continue_button = uicontrol('Position', [1 1 200 40], 'String', 'Continue', 'Callback', 'uiresume(gcbf)');
            predict_button = uicontrol('Position', [250 1 200 40], 'String', 'Preview', 'Callback', 'Maze_Preview_MH');
            %closeall_button = uicontrol('Position', [500 1 100 40], 'String', 'Close All', ...
            %                      'Callback', 'close all');
            disp('Waiting for user to select maze coordinates');
            uiwait(f);
            pos = getPosition(h);
            coord.SW = [pos(1,1), pos(1,2)];
            coord.SE = [pos(2,1), pos(2,2)];
            coord.NE = [pos(3,1), pos(3,2)];
            coord.NW = [pos(4,1), pos(4,2)];
            coord.line = getPosition(ll);
            
            coord.center_rot = atand((max(coord.line(:,1))-min(coord.line(:,1)))/(max(coord.line(:,2)-min(coord.line(:,2)))));
            
            coord.west_arm_rot = atand((coord.NW(1)-coord.SW(1))/(coord.NW(2)-coord.SW(2)));
            coord.east_arm_rot = atand((coord.NE(1)-coord.SE(1))/(coord.NE(2)-coord.SE(2)));
            
            coord.center_rot = mean([coord.center_rot, coord.west_arm_rot, coord.east_arm_rot]);
            coord.theta_deg = (coord.center_rot);
            coord.theta_rad = deg2rad(coord.theta_deg);
            close all %close(f);
            filename = fullfile(savefolder, 'maze_coordinates.mat');
            save(filename, 'coord')
            clear coord
        end
    end
end

%--------------------------------------------------------------------------
% Start analyze positions
% cycle through each recording day and each recording phase
for i = AnalyzeSes(1:end) % which day
      
    fprintf('Running session %d\n',i); %disp(i)    
    
    % load coordination
    load(fullfile(sessInfo(i).mainDir,'processedData', 'maze_coordinates.mat'));
            
    mainDir = sessInfo(i).mainDir;
        
    % create the folder to save tracking images
    savedir = fullfile(mainDir,'TrackingImages');
    if ~exist(savedir, 'dir')
        mkdir(savedir);
    end
            
    %----------------------------------------------------------------------
    % delay session position extraction
    
    % get each phase names (no delay etc)
    SessDirs = sessInfo(i).sessDirs; 
    if prod(~isempty(char(SessDirs{1})))
        indata = [];
        for ii = 1:length(SessDirs) % delay sessions         
            % Get the name of the video file
            videoFile = fullfile(mainDir,SessDirs{ii},'VT1.Nvt');
            if ~exist(videoFile,'file')
                errordlg(sprintf('Missing file: %s',videoFile));
            end
            
            figure(ii) 
            set(gcf, 'Position', [100 100 1500 500]);
            subplot(1,3,1)
            [t, x, y, angle] = ProcessVideoData2(videoFile,sessInfo(i).diode,p); 
            n_trackingPoints = length(x);
            validPosInd = ones(n_trackingPoints,1);
            % becuase it is saved in the output, so I kept it           
            set (gca,'YDir','reverse')
            axis equal
            TITLE = strcat(SessDirs{ii},' -','OriginalPath');
            title(TITLE,'Interpreter', 'none');
            
            % interpolate
            % interpolate position
            [x,y] = interpolatePosition_sl(x,y,p.timeThreshold,p.sampRate) ;
            nanInd = isnan(x);
            x=x(~nanInd);
            y=y(~nanInd);
            t=t(~nanInd);
            n_NaNPoints = sum(nanInd);
            
            % scale / rotate maze and center
            subplot(1,3,2)
            [x,y, ~, ~,maze,~] = ScaleMaze(x, y, coord, p.mazeSize, savedir,0,[]);
            % save the original amout of x, y and t to x_1,,y_1 and t_1
            x_1 = x;
            y_1=y;
            t_1=t;
            set (gca,'YDir','reverse')
            % calculte speed based on scaled positions
            IND=[];
            [v vmean] = getVelocity2(x,y,t);
            ind = (v > p.speed);
            while sum(ind) > 0
                IND = [IND,find(ind==1)];
                t(ind) = [];
                x(ind) = [];
                y(ind) = [];
                angle(ind) = [];
                [v vmean] = getVelocity2(x,y,t);
                ind = (v > p.speed);
            end
            
            plot(x_1(IND),y_1(IND),'r*')
            axis equal
            TITLE = {strcat(SessDirs{ii},' -','Smoothed-Scaled-Rotated');'Not speed thresholded'};
            title(TITLE,'Interpreter', 'none');
            
            % clear NaN positions together with time      
            n_NaNPoints = n_NaNPoints + length(IND);
   
 
            subplot(1,3,3)
            plot(x,y)
            set (gca,'YDir','reverse')
            hold on
            axis equal
            TITLE1 = strcat(SessDirs{ii},' -','Speed threshold-Interpolated');
            TITLE2 = 'Idealized path (red)';
            TITLE2 = 'Maze segment defined';
            title({TITLE1;TITLE2},'Interpreter', 'none');
                      
            %  Put all data into the struct array
            indata = [indata; struct('x',x', 'y',y', 't',t', 'angle',angle,'v',v,'n_trackingPoints',n_trackingPoints,'n_NaNPoints',n_NaNPoints)];
        end
        
        % indata is not used in this set of analysis. I keep it here in
        % case people use it
        % Li, UCSD, 13-Nov-2019
        IndataFolder = strcat(sessInfo(i).mainDir,'\processedData');
        if  ~exist(IndataFolder, 'dir')
            mkdir(IndataFolder);
        end
        if p.overwrite
            Indatafile = strcat(IndataFolder,'\','indataB');
            target = p.mazeSize;
            save(Indatafile,'indata','target');
        end
        
        pathData = indata;       
        
        disp('-> Idealizing Path');
        [pathDataIdeal, locInfo, maze] = idealizepath2(pathData,p.mazetype,p);
        disp('-> Done');

        trialInfo = trialsFromLoc(locInfo);       
        pathDataLin = linearizepath(pathDataIdeal,trialInfo);
        
        % parse info calculated in previous code was not used in my code
        % parse definition need to be adjusted based on maze as well
%         parseInfo = parsepath(pathDataIdeal,parsingtemplate(p.parsemode,p.mazetype));
%         parseInfo = parseinfo2trial(parseInfo, trialInfo);
        % Li Yuan, Aug-05-2020, UCSD
        
        for ii = 1:length(SessDirs)             
            figure(ii)
            subplot(1,3,3)
            plot(pathDataIdeal(ii).x,pathDataIdeal(ii).y,'r')
%             plotMazeDef(maze)
            figName = strcat(savedir,'\',SessDirs{ii},'-','Processed path');
            print(figName,'-dpng','-r300');
        end
        
        close all % close all figures
                
                
        % separate by subtrial (block) and save in respective folder:
        % locInfo, pathData, pathDataIdeal, pathDataLin, trialInfo
        rememberWhoDidntGetSaved = [];
        
        for s = 1:length(SessDirs)
            li = locInfo(s);
            pd = pathData(s);
            pdi = pathDataIdeal(s);
            pdl = pathDataLin(s);
            ti = trialInfo(s);
            
%             pri.inds = parseInfo{s};
%             pri.tInt = ti.tInt;
%             pri.direction = ti.direction;
%             pri.success = ti.success;
            
            if ~exist(fullfile(mainDir,SessDirs{s}, 'locInfo.mat'), 'file') || p.overwrite
                save(fullfile(mainDir,SessDirs{s}, 'locInfo.mat'),'-struct','li');
            else
                rememberWhoDidntGetSaved{end+1} = fullfile(mainDir,SessDirs{s}, 'locInfo.mat');
            end
            if ~exist(fullfile(mainDir,SessDirs{s}, 'pathData.mat'), 'file') || p.overwrite
                save(fullfile(mainDir,SessDirs{s}, 'pathData.mat'),'-struct','pd');
            else
                rememberWhoDidntGetSaved{end+1} = fullfile(mainDir,SessDirs{s}, 'pathData.mat');
            end
            if ~exist(fullfile(mainDir,SessDirs{s}, 'pathDataIdeal.mat'), 'file') || p.overwrite
                save(fullfile(mainDir,SessDirs{s}, 'pathDataIdeal.mat'),'-struct','pdi');
            else
                rememberWhoDidntGetSaved{end+1} = fullfile(mainDir,SessDirs{s}, 'pathDataIdeal.mat');
            end
            if ~exist(fullfile(mainDir,SessDirs{s}, 'pathDataLinear.mat'), 'file') || p.overwrite
                save(fullfile(mainDir,SessDirs{s}, 'pathDataLinear.mat'),'-struct','pdl');
            else
                rememberWhoDidntGetSaved{end+1} = fullfile(mainDir,SessDirs{s}, 'pathDataLinear.mat');
            end
            if ~exist(fullfile(mainDir,SessDirs{s}, 'trialInfo.mat'), 'file') || p.overwrite
                save(fullfile(mainDir,SessDirs{s}, 'trialInfo.mat'),'-struct','ti');
            else
                rememberWhoDidntGetSaved{end+1} = fullfile(mainDir,SessDirs{s}, 'trialInfo.mat');
            end
%             if ~exist(fullfile(mainDir,SessDirs{s}, 'parsingInfo.mat'), 'file') || p.overwrite
%                 save(fullfile(mainDir,SessDirs{s}, 'parsingInfo.mat'),'-struct','pri');
%             else
                rememberWhoDidntGetSaved{end+1} = fullfile(mainDir,SessDirs{s}, 'trialInfo.mat');
        end
    end
    %----------------------------------------------------------------------
    
    %----------------------------------------------------------------------
    % sleep box position extraction
    SleepDirs = sessInfo(i).sleepDirs; 
    if prod(~isempty(char(SleepDirs{1})))
        indata = [];
        for jj = 1:length(SleepDirs) % sleep box
            % Get the name of the video file
            videoFile = fullfile(sessInfo(i).mainDir,SleepDirs{jj},'VT1.Nvt');
            if ~exist(videoFile,'file')
                errordlg(sprintf('Missing file: %s',videoFile));
            end
            
            subplot(1,3,1)
            set(gcf, 'Position', [100 100 1500 500]);
            [t, x, y, angle] = ProcessVideoData2(videoFile,sessInfo(i).diode,p);
            n_trackingPoints = length(x);      
%             axis equal
            TITLE = strcat(SleepDirs{jj},' -','OriginalPath');
            title(TITLE,'Interpreter', 'none');
            
            % interpolate
            % interpolate position
            [x,y] = interpolatePosition_sl(x,y,p.timeThreshold,p.sampRate) ;
            nanInd = isnan(x);
            x=x(~nanInd);
            y=y(~nanInd);
            t=t(~nanInd);
            n_NaNPoints = sum(nanInd);
            
            % scale / rotate maze and plot / save figures
            % there are two way to scale sleep box
            % 1. use the pixel to cm conversion calculated from fig8 maze
            % 2. Define the size of sleep box
            % here I use method 2 for now
            % Li Yuan, Aug-05-2020, UCSD
            subplot(1,3,2)
            [x,y, ~,~,maze] = ScaleMaze_Sleep(x, y, p.sleepSize);          
            plot(x,y);
%             axis tight
            hold on
            
            % calculte speed based on scaled positions
            % calculte speed based on scaled positions
            IND=[];
            [v vmean] = getVelocity2(x,y,t);
            ind = (v > p.sleepSpeed);
            while sum(ind) > 0
                IND = [IND,find(ind==1)];
                t(ind) = [];
                x(ind) = [];
                y(ind) = [];
                angle(ind) = [];
                [v vmean] = getVelocity2(x,y,t);
                ind = (v > p.sleepSpeed);
            end
            
%             plot(x_1(IND),y_1(IND),'r*')
%             axis equal
            TITLE = {strcat(SessDirs{ii},' -','Smoothed-Scaled-Rotated');'Not speed thresholded'};
            title(TITLE,'Interpreter', 'none');
            
            % clear NaN positions together with time      
            n_NaNPoints = n_NaNPoints + length(IND);
            
            figName = strcat(savedir,'\',SleepDirs{jj},'-','Smoothed-Scaled');
            print(figName,'-dpng','-r300');
            
            
            subplot(1,3,3)
            plot(x,y)
            axis equal
            TITLE = strcat(SleepDirs{jj},' -','Speed threshold-Interpolated');
            title(TITLE,'Interpreter', 'none');
            figName = strcat(savedir,'\',SleepDirs{jj},'-','Speed-Interpolated');
            print(figName,'-dpng','-r300');
            close all

            %  Put all data into the struct array
            indata = [indata; struct('x',x', 'y',y', 't',t', 'angle',angle,'v',v,'n_trackingPoints',n_trackingPoints,'n_NaNPoints',n_NaNPoints)];
        end
        
        IndataFolder = strcat(sessInfo(i).mainDir,'\processedData');
        if  ~exist(IndataFolder, 'dir')
            mkdir(IndataFolder);
        end
        
        if p.overwrite
            Indatafile = strcat(IndataFolder,'\','indataS');
            target = p.sleepSize;
            save(Indatafile,'indata','target');
        end
        close all
    end
    %----------------------------------------------------------------------
    %----------------------------------------------------------------------
end
    fprintf('Finished position analysis for session %d\n',i);
end
